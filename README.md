# ğŸ§® ê³„ì‚°ê¸° [STEP 2]
> í”¼ì—°ì‚°ìì™€ ì—°ì‚°ì ë¦¬ìŠ¤íŠ¸ë¥¼ ë¬¸ìì—´ í˜•íƒœë¡œ ì „ë‹¬í•˜ë©´ ì´ë¥¼ ì—°ì‚°ì ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•˜ê³  ìˆ«ì(Double)ë¡œ ë³€í™˜í•˜ì—¬ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
>> **ë¹„ê³ ì‚¬í•­**
>> 1. <details><summary>(Toggle) <U>ì •í•´ì§„ UML</U>ì„ ê¸°ë°˜ìœ¼ë¡œ íƒ€ì…ì„ ìƒì„±í•˜ì˜€ìŠµë‹ˆë‹¤.</summary><div markdown="1"><img src="https://hackmd.io/_uploads/ByY8jQJvn.png"></div></details>
>> 2. STEP 1ì—ì„œ êµ¬í˜„í•œ Queueë¥¼ í™œìš©í•˜ì˜€ìŠµë‹ˆë‹¤.



<br><br>
## ëª©ì°¨ğŸ“Œ
1. [íŒ€ì›ì†Œê°œ](##íŒ€ì›ì†Œê°œğŸ‘©â€ğŸ’»)
2. [íƒ€ì„ë¼ì¸](##íƒ€ì„ë¼ì¸ğŸ—“ï¸)
3. [ë‹¤ì´ì–´ê·¸ë¨](##ë‹¤ì´ì–´ê·¸ë¨ğŸ“Š)
4. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](##íŠ¸ëŸ¬ë¸”ìŠˆíŒ…ğŸš¨)
5. [ì°¸ê³ ìë£Œ](##ì°¸ê³ ìë£ŒğŸ“˜)
6. [íšŒê³ ](##íšŒê³ ğŸ“)

<br><br>
## íŒ€ì›ì†Œê°œğŸ‘©â€ğŸ’»
| <img src="https://hackmd.io/_uploads/r1rWKewLn.png" width="200"/> |
| :-: |
| [**maxhyunm**](https://github.com/maxhyunm)<br/> |

<br><br>
## íƒ€ì„ë¼ì¸ğŸ—“ï¸
ì‘ì—… ì§„í–‰ ê¸°ê°„ | 23.06.01.(ëª©) ~ 23.06.08.(ê¸ˆ)

| ë‚ ì§œ | ì§„í–‰ ì‚¬í•­ |
| -------- | -------- |
| 23.06.01.(ëª©)     | Operator íƒ€ì… ìƒì„±<br/>â†³ add(), subtract(), multiply(), divide() ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ / êµ¬í˜„ / ë¦¬íŒ©í† ë§ <br/><br/>Formula íƒ€ì… ìƒì„±<br/>â†³ result() ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ / êµ¬í˜„ / ë¦¬íŒ©í† ë§<br/><br/>EspressionParsor íƒ€ì… ìƒì„±<br/>â†³ parse() ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ / êµ¬í˜„ / ë¦¬íŒ©í† ë§<br/>â†³ componentsByOperators() ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ / êµ¬í˜„ / ë¦¬íŒ©í† ë§|
| 23.06.02.(ê¸ˆ)     |ExpressionParser ë¦¬íŒ©í† ë§, í…ŒìŠ¤íŠ¸ ì¶”ê°€<br/>CalculatorItemNodeì— ì œë„¤ë¦­ ì„¤ì • ì¶”ê°€<br/>íŒŒì¼ ìœ„ì¹˜ ì •ë¦¬      |
| 23.06.03.(í† )     |ì œë„¤ë¦­ íƒ€ì…ëª… ìˆ˜ì •(T->Element)     |
| 23.06.05.(ì›”)     |í•„ìš”ì—†ëŠ” ë³€ìˆ˜ ì œê±°, ê°œí–‰ ì¶”ê°€     |
| 23.06.08.(ëª©)     |README ì‘ì„±      |


<br><br>
## íŠ¸ëŸ¬ë¸”ìŠˆíŒ…ğŸš¨

### 1ï¸âƒ£ íƒ€ì…ìºìŠ¤íŒ… <br>
ğŸ”’ **ë¬¸ì œì **
>ì—°ì‚°ì„ ìœ„í•œ QueueëŠ” CalculateItem í˜•íƒœë¡œ ìš”ì†Œë¥¼ ì €ì¥í•˜ê³ , ì‹¤ì œ ì—°ì‚°ì€ CalculateItemì„ ì¤€ìˆ˜í•˜ëŠ” Doubleê³¼ Operator íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë‹¤ ë³´ë‹ˆ ë§¤ë²ˆ ë‹¤ìš´ìºìŠ¤íŒ…ì„ í•´ì•¼ í•˜ëŠ” ë²ˆê±°ë¡œì›€ì´ ìˆì—ˆìŠµë‹ˆë‹¤.
```swift=
while true {
    do {
        guard let rhs = try operands.dequeue() as? Double else {
            throw CalculatorError.invalidInput
        }
        ...
        guard let newOperator = try operators.dequeue() as? Operator else {
            throw CalculatorError.invalidOperator
        }
    ...

```


ğŸ”‘ **í•´ê²°ë°©ë²•**
>QueueTypeì— associatedtypeì„ ì¶”ê°€í•˜ê³ , í•´ë‹¹ í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•˜ëŠ” íƒ€ì…ë“¤ê³¼ CalculateItemNode íƒ€ì…ì— ì œë„¤ë¦­ì„ ì¶”ê°€í•˜ì—¬ íƒ€ì…ìºìŠ¤íŒ… ë¬¸ì œë¥¼ í•´ê²°í•˜ì˜€ìŠµë‹ˆë‹¤.
```swift=

protocol QueueType {
    associatedtype Item where Item: CalculateItem
    
    mutating func enqueue(_ value: Item)
    mutating func dequeue() throws -> Item
    mutating func removeAll()
}
```
```swift=
class CalculatorItemNode<Element: CalculateItem> {
    private(set) var value: Element
    private(set) var next: CalculatorItemNode?
    
    init(_ value: Element) {
        self.value = value
    }
    ...
```
---
### 2ï¸âƒ£ parse() ë§ˆì´ë„ˆìŠ¤ ë¶€í˜¸ ì²˜ë¦¬<br>
ğŸ”’ **ë¬¸ì œì **<br>
>ë¹¼ê¸° ì—°ì‚°ìì™€ ë§ˆì´ë„ˆìŠ¤ë¶€í˜¸ë¥¼ êµ¬ë¶„í•˜ëŠ” ë°©ë²•ì— ìˆì–´ ê³ ë¯¼ì´ ë§ì•˜ìŠµë‹ˆë‹¤. ì²˜ìŒì—ëŠ” ë§ˆì´ë„ˆìŠ¤ ë¶€í˜¸ë¥¼ "!"ë¡œ ë³€í™˜í•˜ì—¬ ì§„í–‰ í›„ ë‹¤ì‹œ ë³€í™˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆì§€ë§Œ, ë„ˆë¬´ ë¹„íš¨ìœ¨ì ì´ì—ˆìŠµë‹ˆë‹¤.
```swift=
static func parse(from input: String) throws -> Formula {
    ...
    let operatorWithMinus = [(before: "+-", after: "+!"),
                             (before: "--", after: "-!"),
                             (before: "/-", after: "/!"),
                             (before: "*-", after: "*!")]
    let inputValue = operatorWithMinus.reduce(input) { inputString, operatorType in
        inputString.replacingOccurrences(of: operatorType.before, with: operatorType.after)
    }
    ...
}

static private func componentsByOperators(from input: String) -> [String] {
    ...
    inputValues = inputValues.replacingOccurrences(of: "!", with: "-")
    ...
}
```
ğŸ”‘ **í•´ê²°ë°©ë²•** <br>
> ìŠ¤í† ë¦¬ë³´ë“œ ë²„íŠ¼ íƒ€ì´í‹€ê°’ìœ¼ë¡œ ë“¤ì–´ê°„ ë¹¼ê¸° ì—°ì‚°ìê°€ ë§ˆì´ë„ˆìŠ¤ ë¶€í˜¸ì™€ ë¹„ìŠ·í•œ í˜•íƒœì´ì§€ë§Œ ì‚´ì§ ë‹¤ë¥¸ ë¬¸ìì—´ë¡œ ë˜ì–´ ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œì•˜ê³ , ì´ ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ í™œìš©í•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë§ˆì´ë„ˆìŠ¤ ë¶€í˜¸ì™€ êµ¬ë¶„ì´ ë  ê²ƒì´ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤. ë•ë¶„ì— ë³µì¡í–ˆë˜ ë¡œì§ì´ ë§¤ìš° ê°„ê²°í•´ì¡ŒìŠµë‹ˆë‹¤.

```swift=
static func parse(from input: String) -> Formula {
    ...
    let operandComponents = self.componentsByOperators(from: input).compactMap { Double($0) }
    let operatorComponents = input.compactMap { Operator(rawValue: $0) }
    ...
}
```
---
### 3ï¸âƒ£ ExpressionParser ë©”ì„œë“œ ê¸°ëŠ¥ ë¶„ë¦¬<br>
ğŸ”’ **ë¬¸ì œì **<br>
>ì´ë¯¸ ì‘ì„±ëœ UMLì„ í† ëŒ€ë¡œ ì§„í–‰í•˜ë‹¤ ë³´ë‹ˆ ê° ë©”ì„œë“œì˜ ì—­í• ì´ ì–´ë–¤ ê²ƒì¸ì§€ í™•ì‹¤íˆ íŒŒì•…í•˜ê¸°ê°€ ì–´ë ¤ì› ìŠµë‹ˆë‹¤. ë˜í•œ 1ë²ˆì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ì „ì—ëŠ” ë§ˆì´ë„ˆìŠ¤ ë¶€í˜¸ ë¶€ë¶„ê¹Œì§€ í¬í•¨í•˜ì—¬ ë¡œì§ì´ ë”ìš± ë³µì¡í•˜ê³ , ê¸°ëŠ¥ë³„ë¡œ ë©”ì„œë“œê°€ ì œëŒ€ë¡œ êµ¬ë³„ëœ ëŠë‚Œì´ ë“¤ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. íŠ¹íˆ componentsByOperators() ê°™ì€ ê²½ìš° ì—°ì‚°ìë¥¼ í† ëŒ€ë¡œ ë¬¸ìì—´ì„ ìª¼ê°œëŠ” ê¸°ëŠ¥ì„ í•˜ëŠ” ë©”ì„œë“œê°€ ë§ëŠ”ì§€ ëª…í™•í•˜ì§€ ì•Šì•„ ë³´ì˜€ìŠµë‹ˆë‹¤.
```swift
static private func componentsByOperators(from input: String) -> [String] {
     let allOperators = Operator.allCases.map { $0.rawValue }

     var inputValues = allOperators.reduce(input) { inputString, operatorType in
         inputString.split(with: operatorType).joined(separator: "|")
     }
     inputValues = inputValues.replacingOccurrences(of: "!", with: "-")
     let result = inputValues.split(with: "|")
     return result
 }
```

ğŸ”‘ **í•´ê²°ë°©ë²•** <br>
>ë©”ì„œë“œì˜ ì´ë¦„ì„ í† ëŒ€ë¡œ ì •í™•íˆ ì–´ë–¤ ì—­í• ì„ í•´ì•¼í•˜ëŠ”ì§€ë¥¼ ì¬ì •ë¦¬í–ˆê³ , ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ë¡œì§ì„ ì³ë‚´ì–´ ì •ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì„ ê±°ì¹˜ë©´ì„œ ì „ì²´ì ì¸ ë¡œì§ì´ ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ì•¼ í•˜ëŠ”ì§€ë„ ì¡°ê¸ˆ ë” ëª…í™•í•´ì¡ŒìŠµë‹ˆë‹¤. ë˜í•œ returnì—ì„œ ë°”ë¡œ í•¨ìˆ˜ ê²°ê³¼ë¥¼ ë¦¬í„´í•  ìˆ˜ ìˆë„ë¡ í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë³€ìˆ˜ ì‚¬ìš©ì„ ì¤„ì˜€ìŠµë‹ˆë‹¤.
```swift=
static private func componentsByOperators(from input: String) -> [String] {
    return Operator.allCases.reduce([input]) { resultArray, operatorItem in
        resultArray.map { $0.split(with:operatorItem.rawValue) }.flatMap { $0 }
    }
}

extension String {
    func split(with target: Character) -> [String] {
        return components(separatedBy: String(target))
    }
}
```
---
### ğŸ¤” ê³ ë¯¼í–ˆë˜ ì  <br>
> ì´ë¯¸ ì •ë¦¬ëœ UMLì„ í† ëŒ€ë¡œ íƒ€ì…ê³¼ ë©”ì„œë“œì˜ ì—­í• ì„ ì¶”ë¡ í•˜ë©° ì‘ì—…í•˜ëŠ” ë°©ì‹ì´ ìµìˆ™í•˜ì§€ ì•Šì•„ì„œ í‰ì†Œë³´ë‹¤ ëŒ€ëŒ€ì ì¸ ë²”ìœ„ë¡œ ë¦¬íŒ©í† ë§ì„ ë°˜ë³µí–ˆë˜ ìŠ¤í…ì…ë‹ˆë‹¤. ì²˜ìŒì—ëŠ” TDDë¥¼ ì¤€ìˆ˜í•˜ë ¤ í–ˆì§€ë§Œ, ì´ ê³¼ì •ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì„  êµ¬í˜„ í›„ ìœ ë‹›í…ŒìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ ì§„í–‰í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ë¶€ë¶„ì„ ê°œì„ í•˜ê¸° ìœ„í•´ì„œëŠ” ì‘ì—…ì— ë“¤ì–´ê°€ê¸° ì „ì— ê° íƒ€ì…ì— ëŒ€í•œ ì¶©ë¶„í•œ ê³ ë¯¼ê³¼ ìƒì„¸í•œ ì •ë¦¬ê°€ í•„ìš”í•  ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.


<br><BR>
## ì°¸ê³ ìë£ŒğŸ“˜
- [The Swift Programming Language - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics/)
- [Apple Developer Documentation - reduce(_: _:)](https://developer.apple.com/documentation/swift/array/reduce(_:_:))
- [Apple Developer Documentation - map(_:)](https://developer.apple.com/documentation/swift/array/map(_:)-87c4d)
- [Apple Developer Documentation - flatMap(_:)](https://developer.apple.com/documentation/swift/array/flatmap(_:)-6chu8)

<br><BR>
## íšŒê³ ğŸ“
ğŸ‘ ìµìˆ™í•˜ì§€ ì•Šì•˜ë˜ ì œë„¤ë¦­ ì‚¬ìš©ê³¼ ê³ ì°¨í•¨ìˆ˜ ì‚¬ìš©ì„ í†µí•´ ë‹¤ì–‘í•œ êµ¬í˜„ì— ì„±ê³µí•œ ì <br/>
ğŸ‘ ì‹œê°„ ë‚´ì— ì˜ ë§ˆë¬´ë¦¬í•œ ì <br/>
ğŸ‘ ì‚¬ì „ì— íƒ€ì…ê³¼ ë©”ì„œë“œì— ëŒ€í•œ íŒŒì•…ì„ ì¶©ë¶„íˆ ì§„í–‰í•˜ì§€ ì•Šì•„ ë§ì€ ìˆ˜ì •ì„ ê±°ì¹œ ì <br/>



